# **Deploying with AWS ECS: A Managed Docker Container Service**

## **1. Objective**

Repeat the earlier deployment (previously done with EC2) but **using AWS ECS**, where AWS manages the underlying infrastructure for you.

This means:

* No manual creation of EC2 instances
* No installing Docker on a machine
* No managing updates, restarts, or scaling
* AWS handles the servers
* You only define *how* containers should run

---

# **2. Important Disclaimer**

* ECS and related services **may not be free**.
* They might fall outside the AWS Free Tier.

---

# **3. ECS Overview: The Four Fundamental Concepts**

ECS uses four building blocks:

### **1) Containers**

Your Docker containers (built from your images).
You configure:

* Name
* Image URL
* Ports
* Memory
* Environment variables
* Logging options
  Think of this as configuring parameters for a future `docker run`.

---

### **2) Tasks**

A **task definition** is a blueprint describing *how AWS should run your container(s)*.

A task can include:

* One container
* Or multiple containers (e.g., backend + DB)

Tasks are similar to:

* “One remote machine running containers”

But AWS manages the machine for you.

You typically run tasks on **Fargate**.

---

### **3) Services**

A service defines:

* How many tasks should run
* Whether tasks should restart if they fail
* Whether to use load balancers
* How the task should scale

It ensures:

* Minimum number of containers stay running
* Traffic can be balanced (if configured)

---

### **4) Clusters**

A cluster is a logical grouping of tasks/services.

Think of it as:

* A container-specific virtual network
* The “home” for tasks and services
  Allows multi-container apps to communicate.

---

# **4. ECS Deployment Flow in the Wizard**

## **Step 1 — Choose Container**

* Click “Get Started”
* Select **Custom container**
* Enter container name (e.g., *node-demo*)
* Enter image from Docker Hub

  * e.g., `yourname/node-example-1`
  * ECS automatically pulls from Docker Hub
* Configure:

  * Port mapping → expose port 80
  * Env vars
  * Logging (CloudWatch optional)
  * Storage (volumes)

This is effectively defining what would normally be inside:

```bash
docker run --name node-demo -p 80:80 yourname/node-example-1
```

---

## **Step 2 — Define Task**

The task = machine configuration + container configuration.

Using **Fargate**:

* Execution is “serverless”
* No EC2 instance is created
* Container wakes up only when needed → cost efficient

Defines:

* Memory & CPU for the task
* Network mode
* What containers belong to this task

---

## **Step 3 — Define Service**

The service manages how the task is run:

Options here include:

* Desired number of copies (1 task, 2 tasks, etc.)
* Load balancers (not used yet here)
* Deployment settings

For now, run 1 task without a load balancer.

---

## **Step 4 — Define Cluster**

The cluster is:

* Networking + security environment
* Logical grouping for all tasks/services

AWS auto-creates required networking (VPC, subnets, security groups).

Click **Next → Create**.

AWS now:

* Creates the cluster
* Creates the service
* Creates the task
* Pulls the image
* Prepares networking
* Launches the container when requested

This setup takes a few minutes.

---

# **5. Viewing and Testing the Running Container**

Once created:

* Go to **Tasks**
* Click the task **ID** (not the definition)
* Find the **public IP**
* Open it in your browser → your Node app is live

You could also map a domain to this IP.

---

# **6. Key Advantages of Using ECS**

* No manual server setup
* No updates to install
* No Docker installation required
* No maintaining EC2 instances
* No infrastructure management
* Purely configure-and-run approach

AWS manages everything behind the scenes.
