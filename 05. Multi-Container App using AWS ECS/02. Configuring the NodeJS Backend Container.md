# **Configuring the NodeJS Backend Container (AWS ECS Multi-Container Setup)**

-->  walking through setting up the **Node.js backend container** inside a new ECS cluster, preparing it for multi-container deployment alongside MongoDB.

---

# **1. Create a New ECS Cluster**

Since the previous cluster was deleted:

1. Go to **ECS → Create Cluster**
2. Select **Networking only (Fargate)**
3. Name the cluster (e.g. `goals-app`)
4. Check **Create VPC** (use defaults)
5. Click **Create**

A cluster is essentially a **network environment (VPC, subnets)** in which your tasks/services run.

---

# **2. Create a New Task Definition**

Go to **Task Definitions → Create new task definition**:

1. Choose **Fargate**
2. Give it a name (e.g. `goals`)
3. Select the **ECS task execution role**

   * If it's missing → redo the First Run Wizard to generate it
4. Choose smallest **CPU** and **memory** (demo only)
5. Add container definitions

---

# **3. Add the Backend Container**

Click **Add Container**:

### **Container Name**

`goals-backend` (or similar)

### **Image**

Your Docker Hub backend image, e.g.:

```
nidhalhaamdii/goals-node
```

### **Port Mapping**

Expose port **80**, because the backend listens on port 80 inside the container.

---

# **4. Important: Change the Container Startup Command**

In the Dockerfile, the default command is:

```
npm start
```

This runs **nodemon**, which is for local development only (live reload).

In production, you **should not** use nodemon.

Instead, override the command in ECS:

### **Command**

```
node app.js
```

This uses the real Node.js runtime, without development tooling.

This demonstrates how Docker allows you to:

* Use the *same image* for development and production
* But *override commands* depending on the environment

---

# **5. Environment Variables**

Your backend now relies on three env vars:

* `MONGODB_USERNAME`
* `MONGODB_PASSWORD`
* `MONGODB_URL`

These must be added:

### **Important: Update your Dockerfile**

You must add:

```
ENV MONGODB_URL=...
```

(Or simply ensure the variable exists so Node.js can read it.)

Then:

* Rebuild image
* Retag
* Push updated image to Docker Hub

Because ECS will pull the new image.

---

# **6. Add Environment Variables in ECS**

In the container configuration, add:

### From `.env` (local development):

```
MONGODB_USERNAME=...
MONGODB_PASSWORD=...
```

### BUT change the MongoDB URL for ECS:

* Locally you used:

  ```
  MONGODB_URL=mongodb
  ```

  Because docker-compose networks resolve container names.

* In AWS ECS:

  ```
  MONGODB_URL=localhost
  ```

### Why?

Because:

* Backend and MongoDB will be in the **same ECS Task**
* ECS gives them a *shared localhost network*
* So containers can reach each other via `localhost:27017`

Docker Compose resolves container names instead.
ECS does NOT do this.

---

# **7. No Volumes Needed**

In production:

* No bind mounts
* No hot-reloading
* No local log folder
* Node modules handling is automatic

Thus **no volumes** are needed in ECS.

---

# **8. Backend Container Added**

After adding:

* The backend container is fully configured.
* Next step is to add **MongoDB** as a second container in the same ECS task.

---

# **Summary**

You have now:

✔ Created a new ECS cluster
✔ Created a new task definition
✔ Added the backend container
✔ Corrected the startup command (`node app.js`)
✔ Added required environment variables
✔ Prepared the backend to run alongside MongoDB via `localhost`
✔ Ensured the image is rebuilt and updated in Docker Hub

Next step:
**Add the MongoDB container to the same task.**
