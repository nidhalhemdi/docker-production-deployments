# **Building a Multi-Stage Image (Production React App)**

Once the multi-stage Dockerfile (using Node.js â†’ NGINX) is prepared, we must ensure the **React code itself** is compatible with production deployment.

---

## ğŸ”§ 1. Fixing the API Request URLs

In the frontend code, HTTP requests were made to:

```
http://localhost:... 
```

This worked *locally*, but **not in production**, because:

* React code runs **in the browser**, not inside the container.
* So **localhost refers to the userâ€™s machine**, not your AWS ECS server.

Therefore:
â†’ **Localhost must not be used in production React code.**

### **Correct Production URL behavior**

Since the plan is:

* Deploy frontend and backend **in the same ECS task**
* Use the **same domain** for both

Then the frontend should simply request:

```
/goals
```

This automatically targets the same origin hosting the website.
This works perfectly with NGINX and AWS load balancers.

If backend and frontend were deployed on **different servers**, you would instead use:

* The backendâ€™s domain
* Or React build-time environment variables (e.g., `REACT_APP_API_URL`)

But for this demo â†’ **relative URLs are correct**.

---

## ğŸ—ï¸ 2. Building the Production Image (Multi-Stage Dockerfile)

We now want to build the production image based on:

* `Dockerfile.prod`
* A multi-stage Node.js â†’ NGINX setup

And then push it to Docker Hub.

---

## ğŸ³ 3. Create the Docker Hub Repository

On Docker Hub:

* Backend repo: `goals-node`
* Now create frontend repo: **`goals-react`**

This will be the place where you push the production image.

---

## ğŸ³ 4. Build the Production Image (with `Dockerfile.prod`)

Important:
Since this is not named `Dockerfile`, you must use:

```
docker build -f <path to Dockerfile> -t <image-name> <context>
```

### Correct build command:

```
docker build -f frontend/Dockerfile.prod -t nidhalhaamdii/goals-react ./frontend
```

Breakdown:

* `-f frontend/Dockerfile.prod` â†’ the production Dockerfile
* `-t nidhalhaamdii/goals-react` â†’ tag using the Docker Hub repository name
* `./frontend` â†’ build context (the folder to send to the Docker engine)

After running this, Docker:

1. Builds the **Node** stage
2. Runs `npm run build` to generate the optimized React files
3. Switches to the **NGINX** stage
4. Copies build artifacts into NGINXâ€™s `/usr/share/nginx/html`
5. Produces the final minimal production image

Warnings shown during build â†’ **safe to ignore**.

---

## ğŸ“¤ 5. Push the Image to Docker Hub

Same as before:

```
docker push nidhalhaamdii/goals-react
```

This uploads the image so ECS can pull it during deployment.

---

## ğŸš€ 6. Deploy to AWS ECS

Once the production image is pushed:

* ECS can pull `nidhalhaamdii/goals-react`
* You can deploy it alongside the backend image
* Both will run inside the same task â†’ simplifies communication
* Load balancer will serve the React frontend from NGINX

Thus, the production deployment pipeline is complete.
