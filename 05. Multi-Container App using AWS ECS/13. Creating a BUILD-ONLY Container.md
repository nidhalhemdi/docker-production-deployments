#  **Creating a “Build-Only” Container (React App Deployment)**

A React application behaves differently in **development** vs **production**, so we need **two different Docker environments**:

---

## **1. Development vs Production Setup**

### **Development**

* We run `npm start`.
* This launches a **development server** (a Node.js server) with:

  * Live reloading
  * Unoptimized bundle
* Therefore **Node.js is required** inside the development container.

### **Production**

* We run `npm run build`.
* This produces **static optimized files** (`/build` folder).
* These files **do not include a server**.
* Node.js is **NOT needed** unless you build your own server.
* Production requires:

  1. A **build step** → generates optimized static JS/CSS/HTML
  2. A **server** (e.g., NGINX) to serve these static files

Because of this, we can’t use the same Dockerfile for dev and production.

---

## **2. Creating Two Dockerfiles**

You already have your main development Dockerfile.
Now you create a **second Dockerfile**:

```
Dockerfile.prod
```

This file will:

1. Use a smaller base (e.g., `node:24-alpine`)
2. Install dependencies
3. Build optimized frontend files
4. NOT run a dev server
5. NOT expose a port
6. Only produce the final static files

At this stage it’s a **build-only container**, not a serving container.

---

## **3. Structure of `Dockerfile.prod`**

1. **Base image**: a lightweight Node image (e.g. alpine)
2. **Set the working directory**
3. **Copy package.json & install dependencies**
4. **Copy the full app source**
5. **Run `npm run build`**

   * Must use `npm run build` (not `npm build`)

This produces the `/build` folder inside the container.

But… the container has **no server** yet.

---

## **4. Why This Is Not Enough Yet**

Running `npm run build` only produces static assets.
To use this container in production, you need:

* A **web server** (like NGINX) to serve the files
* A **multi-stage Docker build** to:

  * Build the JS/CSS/HTML in stage 1
  * Copy the final optimized files into a small server image in stage 2

This is where **Multi-Stage Builds** come in.

---

## **5. What Comes Next**

Next, we will introduce **multi-stage builds**:

* Stage 1: Build-phase (Node.js environment)
* Stage 2: Run-phase (e.g., NGINX)

This allows you to ship a **very small**, **fast**, **production-ready** Docker image.