# **Deploying a Standalone Frontend App**

## ğŸ”¥ 1. Trying to Add Frontend to the Existing ECS Task â†’ Port Conflict

We try first to:

* Add a second container (`goals-frontend`) to the existing **backend** ECS task.

But this fails because:

* **Both containers expose port 80**
* You **cannot run two web servers on the same ECS task / same host**
* ECS wonâ€™t allow two containers in the same task definition mapping port 80

**Reason:**
Both the Node backend and NGINX frontend are web servers â†’ port 80 conflict.

ğŸ‘‰ **Solution:** They *must* run in **separate ECS tasks** and therefore separate services.

---

# ğŸ—ï¸ 2. Create a NEW Task Definition for the React Frontend

Steps:

1. Create a new Fargate task definition:

   * Name: `goals-react` (or similar)
   * Use same task role
   * Minimum CPU/memory
2. Add container:

   * Image: `nidhalhaamdii/goals-react`
   * Map port **80**
3. No env variables needed.
4. Create task definition.

Now the frontend has its **own task**, separate from backend.

---

# ğŸŒ 3. Why We Need a Second Load Balancer (New URL)

Each ECS service that exposes a web server needs:

* Its own load balancer (unless doing path-based routing, which is not used here).
* Its own target group.

So now we create:

### New Application Load Balancer

* Name: `goals-react-lb`
* Internet-facing
* Port 80
* Same VPC
* Same security group
* New target group: `react-tg`

This load balancer gets its **own DNS name**.
This becomes the **frontend URL**.

---

# ğŸ”§ 4. Update the React Code (Important!)

Originally, the React code used:

```
http://localhost:...
```

This **doesn't work** in production because:

* React runs in the **browser**, not inside the container.
* `localhost` = **the user's machine**, not AWS.

The earlier fix (removing domain and using `/goals`) only works if frontend + backend share the same domain.
But now they run on **different tasks**, so they **have different domains**.

### âœ” Solution: Use React Environment Variables

Create:

```js
const backendUrl =
  process.env.NODE_ENV === 'development'
    ? 'http://localhost'
    : 'http://<BACKEND_LOAD_BALANCER_URL>';
```

Then use:

```js
fetch(backendUrl + '/goals')
```

This makes the code work:

* During development (`npm start`)
* During production (React build injects env vars)

### Why Docker env vars WONâ€™T work:

React code is executed in **the browser**, not inside Docker.
Env vars must come from the **React build process**, not from Docker.

---

# ğŸ—ï¸ 5. Rebuild and Push the Updated Image

After updating the code:

1. Rebuild:

```
docker build -f frontend/Dockerfile.prod -t nidhalhaamdii/goals-react ./frontend
```

2. Push:

```
docker push nidhalhaamdii/goals-react
```

---

# ğŸš€ 6. Create an ECS Service for the Frontend

Use:

* Fargate launch type
* Same cluster (goals-app)
* Service name: `goals-react`
* Tasks: 1
* Rolling updates (default)
* Network:

  * same 2 subnets
  * security group allowing port 80
  * **assign public IP**
* Load balancer:

  * attach `goals-react-lb`
  * use target group `react-tg`

Create service â†’ ECS launches the frontend container.

---

# ğŸŒ 7. Test the App

Once the new service is running:

* Open the **Frontend Load Balancer URL**

The app loads, fetches goals from the backend, and:

âœ… Lists goals
âœ… Creates new goals
âœ… Deletes goals
âœ… Persists backend state

Everything works.

---

# ğŸ¯ Final Takeaways

### âœ” You CANNOT run two web servers (backend + nginx) in the same ECS task.

â†’ They must be separate tasks/services when both expose port 80.

### âœ” Each service needs its own load balancer unless path-based routing is used.

### âœ” React must use its own environment variable system; Docker env vars do not apply.

### âœ” After adjusting the code, rebuild image â†’ push â†’ deploy new ECS service.
