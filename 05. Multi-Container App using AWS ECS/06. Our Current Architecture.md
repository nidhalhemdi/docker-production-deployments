# **Current Application Architecture**

Right now, your deployed application looks like this:

---

## ğŸŸ¦ **1. ECS Task with Two Containers**

Your ECS setup uses **one running task**, and inside that task you have **two containers**:

1. **Node.js REST API**
2. **MongoDB Database**

Both containers run together in the same task definition.

---

## ğŸŸ© **2. Persistent Storage Using EFS**

MongoDB uses an attached **AWS EFS (Elastic File System)** volume to store data.

Why?

* Normally, container storage is temporary
* When ECS restarts or replaces a task, MongoDBâ€™s data would be lost
* EFS ensures the data persists across restarts and deployments

So **MongoDB writes its data to EFS**, not to the containerâ€™s internal filesystem.

---

## ğŸŒ **3. Public Access Through a Load Balancer**

Your application is publicly accessible through an **Application Load Balancer (ALB)**.

* The load balancer provides a **stable, unchanging domain**
* It forwards incoming requests to the **Node.js API container**
* The Node API then interacts with **MongoDB** as needed

This ensures:

âœ” A consistent URL
âœ” No need to care about changing IPs
âœ” Automatic health checks for the tasks

---

## ğŸ” **4. Request Flow Overview**

Hereâ€™s how a user request travels:

1. **User â†’ ALB**
2. **ALB â†’ Node.js REST API (in ECS task)**
3. **Node.js â†’ MongoDB (via internal container link + EFS-backed storage)**
4. **API returns response â†’ ALB â†’ User**

---

## ğŸ§© **In One Sentence**

You currently have a **Node.js + MongoDB** application running in a **single ECS task**,
with **MongoDB data stored persistently using EFS**,
and a **load balancer** providing a stable public entry point.
